#!/usr/bin/env python3

import curses
import vk
from queue import Queue
from threading import Thread
from time import sleep
from signal import signal, SIGTERM, SIGINT

_VERSION = 0.1
_APP_ID = 5586370
_API_VERSION = '5.57'

DialogsToken = 0
MessagesToken = 1


class _dialogs:
    # top - index of top drawed dialog, pos - current position in list, 
    # curr_id - id of currently selected user
    top = 0
    pos = 0
    curr_id = 0
    active = True
    # Every 'updateInterval' seconds ask for update
    updateInterval = 1
    # Response to request
    response = {}

    def __init__(self, stdscr, RequestConveyor, DialogsTransfer):
        # Init window
        y, x = stdscr.getmaxyx()
        self.box = stdscr.subwin(y, x // 4, 0, 0)
        self.window = self.box.derwin(y - 2, x // 4 - 2, 1, 1)
        curses.init_pair(1, curses.COLOR_RED, -1)
        self.boldred = curses.color_pair(1) | curses.A_BOLD

        # Init threads
        self.RequestConveyor = RequestConveyor
        self.DialogsTransfer = DialogsTransfer
        self.updater = Thread(None, self.update, "Dialogs Update Thread")
        self.updater.daemon = True
        self.updater.start()

    def update(self):
        while True:
            self.y, self.x = self.window.getmaxyx()
            # Offset for getting dialogs
            # Subtracted 5 to allow upscrolling dialogs list
            dialogsOffset = 0 if self.top < 5 else self.top - 5 
            # How much dialogs should be got
            # Added 5 to allow downscrolling dialogs list
            dialogsToGet = self.y + 5
            request = """
                        var dialogs = API.messages.getDialogs({
                            "count": """ + str(dialogsToGet) + """,
                            "offset": """ + str(dialogsOffset) + """,
                            "v": """ + str(_API_VERSION) + """});
                        var titles = dialogs.items@.message@.title;
                        var user_ids = dialogs.items@.message@.user_id;
                        var names = API.users.get({
                            "user_ids": user_ids,
                            "v": """ + str(_API_VERSION) + """});
                        var isConference = [];
                        var i = """ + str(dialogsToGet) + """;
                        while (i > 0) {
                            i = i - 1;
                            var name;
                            if (titles[i] == " ... ") {
                                isConference.unshift(false);
                                var j = 0;
                                while (j < names.length) {
                                    if (user_ids[i] == names[j].id) {
                                        name = names[j].first_name + " " + names[j].last_name;
                                    }
                                    j = j + 1;
                                }
                                titles.splice(i, 1, name);
                            }
                            else {
                                isConference.unshift(true);
                            }
                        }
                        return {
                            "total": dialogs.count,
                            "total_unread": dialogs.unread_dialogs,
                            "unread": dialogs.items@.unread,
                            "isConference": isConference,
                            "titles": titles
                        };"""
            self.RequestConveyor.add(request, DialogsToken)

            # Wait for response
            waitingForResponse = True
            while waitingForResponse:
                if not self.DialogsTransfer.empty():
                    waitingForResponse = False
                else:
                    sleep(self.RequestConveyor.interval)
            self.response = self.DialogsTransfer.get()
            self.redraw()
            sleep(self.updateInterval)

    def redraw(self):
        dialogs = self.response # Just to make code more readable
        self.box.erase()

        # Draw header
        self.box.box()
        self.box.addstr(0, 2, "Dialogs: " + str(dialogs['total']), curses.A_BOLD)
        if dialogs['total_unread'] is not None:
            self.box.addstr(" (" + str(dialogs['total_unread']) + ")", self.boldred)

        # Draw dialogs list
        for i in range(self.top, self.top + self.y):
            try:
                # Mark unread dialogs 
                self.window.addstr(i - self.top, 1, "" if dialogs['unread'][i] is None else 
                                            "(" + str(dialogs['unread'][i]) + ") ", self.boldred)
                cy, cx = self.window.getyx()
                # Background for selected dialog
                highlight = curses.A_REVERSE if i == self.pos else 0
                # Bold for conferences
                highlight |= curses.A_BOLD if dialogs['isConference'][i] else 0
                self.window.addnstr(dialogs['titles'][i], self.x - 1 - cx, highlight)
            except:
                pass
        self.box.refresh()


class _messages:
    active = False
    # Every 'updateInterval' seconds ask for update
    updateInterval = 1

    def __init__(self, stdscr, Dialogs, RequestConveyor, MessagesTransfer):

        # Init window
        y, x = stdscr.getmaxyx()
        self.box = stdscr.subwin(y, 3 * x // 4, 0, x // 4)
        self.window = self.box.derwin(y - 2, 3 * x // 4 - 2, 1, 1)

        # Init threads
        self.Dialogs = Dialogs
        self.RequestConveyor = RequestConveyor
        self.MessagesTransfer = MessagesTransfer
        self.updater = Thread(None, self.update, "Messages Update Thread")
        self.updater.daemon = True
        self.updater.start()

    def update(self):
        # How much messages should be got
        messagesToGet = 10
        request = """   var  messages = API.messages.getHistory({
                            "count": """ + str(messagesToGet) + """, 
                            "peer_id": """ + str(self.Dialogs.curr_id) + """, 
                            "v": """ + str(_API_VERSION) + """});
                        return messages.items@.body; """

        self.RequestConveyor.add(request, MessagesToken)

        # Wait for response
        waitingForResponse = True
        while waitingForResponse:
            if not self.MessagesTransfer.empty():
                waitingForResponse = False
            else:
                sleep(self.RequestConveyor.interval)
        self.response = self.MessagesTransfer.get()
        self.redraw()       
        sleep(self.updateInterval)
    
    def redraw(self):
        messages = self.response # Just to make code more readable
        self.box.erase()
        self.box.box()
        self.box.refresh()


class _requestConveyor:
    RequestQueue = []
    # Make requests every 'interval' seconds
    # VK API limits 3 requests per second
    interval = 0.35

    def __init__(self, api, DialogsTransfer, MessagesTransfer):
        self.api = api
        self.DialogsTransfer = DialogsTransfer
        self.MessagesTransfer = MessagesTransfer
        self.timer = Thread(None, self.call, "Request Conveyor Thread")
        self.timer.daemon = True
        self.timer.start()

    def add(self, request, token):
        self.RequestQueue.append({'request': request, 'token': token})
    
    def call(self):
        while True:
            if len(self.RequestQueue) > 0:
                response = self.api.execute(v = _API_VERSION, 
                                            code = self.RequestQueue[0]['request'])
                if self.RequestQueue[0]['token'] == DialogsToken:
                    self.DialogsTransfer.put(response)
                elif self.RequestQueue[0]['token'] == MessagesToken:
                    self.MessagesTransfer.put(response)
                self.RequestQueue.pop(0)
            sleep(self.interval)


def auth(stdscr):
    vk.logger.disabled = True
    notLogged = True
    while notLogged:
        # Get login and password
        stdscr.addstr(1, 1, "vmesg " + str(_VERSION))
        stdscr.addstr(3, 1, "Login: ")
        curses.curs_set(1)
        curses.echo()
        vklogin = stdscr.getstr()
        stdscr.addstr(4, 1, "Password: ")
        curses.noecho()
        vkpass = stdscr.getstr()
        curses.curs_set(0)
        stdscr.addstr(6, 1, "Authorizing...")
        stdscr.refresh()

        # Authorization
        try:
            vksession = vk.AuthSession( app_id=_APP_ID, 
                                        user_login=vklogin, 
                                        user_password=vkpass, 
                                        scope='messages' )
        except vk.exceptions.VkAuthError:
            stdscr.addstr(7, 1, "Incorrect login or password")
        else:
            api = vk.API(vksession)
            try:
                # Just to check if API was initializated succesfully 
                stdscr.addstr(7, 1, "Welcome, " + api.account.getProfileInfo(v = _API_VERSION)['first_name'])
            except vk.exceptions.VkAPIError:
                stdscr.addstr(7, 1, "Cannot authorize")
            else:
                notLogged = False
        finally:
            stdscr.refresh()
            sleep(1)
            stdscr.clear()
    return api


def main(stdscr):
    # Curses setup
    curses.start_color()
    curses.use_default_colors()
    
    # Authorization
    api = auth(stdscr)

    # Data transfers between threads
    DialogsTransfer = Queue()
    MessagesTransfer = Queue()
    # Threads and classes initialization
    RequestConveyor = _requestConveyor(api, DialogsTransfer, MessagesTransfer)
    Dialogs = _dialogs(stdscr, RequestConveyor, DialogsTransfer)
    Messages = _messages(stdscr, Dialogs, RequestConveyor, MessagesTransfer)

    while True:
        key = stdscr.getch()
        # Move through dialogs list
        if Dialogs.active:
            if key == curses.KEY_UP:
                Dialogs.pos -= 1 if Dialogs.pos > 0 else 0
                if Dialogs.pos < Dialogs.top:
                    Dialogs.top -= 1
                Dialogs.redraw()
            elif key == curses.KEY_DOWN:
                Dialogs.pos += 1 if Dialogs.pos < Dialogs.response['total'] else 0
                if Dialogs.pos - Dialogs.top == Dialogs.y:
                    Dialogs.top += 1
                Dialogs.redraw()
            elif key == 0x0A: # Enter key
                Dialogs.active = False
                Messages.active = True
        elif Messages.active:
            if key == 0x1B: # Escape key
                Messages.active = False
                Dialogs.active = True
            Messages.redraw()
 

def finalizate(signum, frame):
    curses.endwin()
    exit()


if __name__ == "__main__":
    signal(SIGTERM, finalizate)
    signal(SIGINT, finalizate)
    curses.wrapper(main)
