#!/usr/bin/env python3

import curses
import vk
from queue import Queue
from threading import Thread
from time import sleep

_VERSION = 0.1
_APP_ID = 5586370
_API_VERSION = '5.57'


class _dialogs:
    topPos = 0
    active = True        
    # Every 'interval' seconds ask for update
    interval = 1

    def __init__(self, stdscr, RequestConveyor, ThreadQueue):
        # Init window
        y, x = stdscr.getmaxyx()
        self.box = stdscr.subwin(y, x // 4, 0, 0)
        self.window = self.box.derwin(y - 2, x // 4 - 2, 1, 1)

        # Init thread
        self.RequestConveyor = RequestConveyor
        self.ThreadQueue = ThreadQueue
        self.updater = Thread(None, self.update, "Dialogs Updating Thread")
        self.updater.start()

    def update(self):
        while True:
            self.box.clear()
            self.box.box()
            self.window.clear()
            request = """   var dialogs = API.messages.getDialogs({"count": 20});
                            return {"total": dialogs.count,
                                "total_unread": dialogs.unread_dialogs,
                                "titles": dialogs.items@.message@.title,
                                "unread": dialogs.items@.unread,
                                "name": API.users.get({"user_ids": dialogs.items@.message@.user_id})};"""
            token = 0
            self.RequestConveyor.add(request, token)
            while not self.ThreadQueue.empty():
                sleep(self.RequestConveyor.interval)
            response = self.ThreadQueue.get()
            dialogs = response['dialogs']

            # Draw header
            self.box.addstr(0, 2, "Dialogs: " + str(dialogs['total']), curses.A_BOLD)
            _BOLDRED = curses.color_pair(1) | curses.A_BOLD
            if dialogs['total_unread'] is not None:
                self.box.addstr(" (" + str(dialogs['total_unread']) + ")", _BOLDRED)

            # Draw dialogs list
            y, x = self.window.getmaxyx()
            for i in range(0, y):
                # Mark unread dialogs 
                self.window.addstr(i, 1, "" if dialogs['unread'][i] is None else 
                                        "(" + str(dialogs['unread'][i]) + ") ", _BOLDRED)
                cy, cx = self.window.getyx()
                # Conference titles
                if dialogs["titles"][i] == " ... ":
                    self.window.addnstr(dialogs['name'][i]['first_name'] + " " + 
                                        dialogs['name'][i]['last_name'], x - 1 - cx)
                # Users' names
                else:
                    self.window.addnstr(dialogs['titles'][i], x - 1 - cx, curses.A_BOLD)
            self.box.refresh()
            self.window.refresh()
            sleep(self.interval)


class _messages:
    active = False

    def __init__(self, stdscr, RequestConveyor):
        self.RequestConveyor = RequestConveyor

        # Init window
        y, x = stdscr.getmaxyx()
        self.box = stdscr.subwin(y, 3 * x // 4, 0, x // 4)
        self.box.box()
        self.window = self.box.derwin(y - 2, 3 * x // 4 - 2, 1, 1)

    def update(self):
        pass


class _requestConveyor:
    RequestQueue = []
    # Make requests every 'interval' seconds
    # VK API limits 3 requests per second
    interval = 0.35

    def add(self, request, token):
        self.RequestQueue.append({'request': request, 'token': token})
    
    def call(self):
        while True:
            if len(self.RequestQueue) > 0:
                self.ThreadQueue.put(
                        {'dialogs': self.api.execute(v = _API_VERSION, code = self.RequestQueue[0]['request']), 
                        'token': self.RequestQueue[0]['token']})
                self.RequestQueue.pop(0)
            sleep(self.interval)

    def __init__(self, api, ThreadQueue):
        self.api = api
        self.ThreadQueue = ThreadQueue
        self.timer = Thread(None, self.call, "Request Conveyor Thread")
        self.timer.start()


def auth(stdscr):
    vk.logger.disabled = True
    notLogged = True
    while notLogged:
        # Get login and password
        stdscr.addstr(1, 1, "vmesg " + str(_VERSION))
        stdscr.addstr(3, 1, "Login: ")
        curses.curs_set(1)
        curses.echo()
        vklogin = stdscr.getstr()
        stdscr.addstr(4, 1, "Password: ")
        curses.noecho()
        vkpass = stdscr.getstr()
        curses.curs_set(0)
        stdscr.addstr(6, 1, "Authorizing...")
        stdscr.refresh()

        # Authorization
        try:
            vksession = vk.AuthSession( app_id=_APP_ID, 
                                        user_login=vklogin, 
                                        user_password=vkpass, 
                                        scope='messages' )
        except vk.exceptions.VkAuthError:
            stdscr.addstr(7, 1, "Incorrect login or password")
        else:
            api = vk.API(vksession)
            try:
                stdscr.addstr(7, 1, "Welcome, " + api.account.getProfileInfo(v = _API_VERSION)['first_name'])
            except vk.exceptions.VkAPIError:
                stdscr.addstr(7, 1, "Cannot authorize")
            else:
                notLogged = False
        finally:
            stdscr.refresh()
            sleep(1)
            stdscr.clear()
    return api


def finit():
    curses.endwin()


def main(stdscr):
    curses.start_color()
    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_RED, -1)
    api = auth(stdscr)

    ThreadQueue = Queue()
    RequestConveyor = _requestConveyor(api, ThreadQueue)
    Dialogs = _dialogs(stdscr, RequestConveyor, ThreadQueue)
    Messages = _messages(stdscr, RequestConveyor)

    stdscr.getch()
    finit()

if __name__ == "__main__":
    curses.wrapper(main)
