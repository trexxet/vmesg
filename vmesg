#!/usr/bin/env python3

import curses
import vk
from queue import Queue
from threading import Thread
from time import sleep
import signal

_VERSION = 0.1
_APP_ID = 5586370
_API_VERSION = '5.57'

DialogsToken = 0
MessagesToken = 1


class _dialogs:
    # top - index of top drawed dialog, pos - current position in list
    top = 0
    pos = 0
    active = True        
    # Every 'updateInterval' seconds ask for update
    updateInterval = 1
    # Response to request
    response = {}

    def __init__(self, stdscr, RequestConveyor, DialogsTransfer):
        # Init window
        y, x = stdscr.getmaxyx()
        self.box = stdscr.subwin(y, x // 4, 0, 0)
        self.window = self.box.derwin(y - 2, x // 4 - 2, 1, 1)
        curses.init_pair(1, curses.COLOR_RED, -1)
        curses.init_pair(2, 0, curses.COLOR_WHITE)
        self.boldred = curses.color_pair(1) | curses.A_BOLD

        # Init threads
        self.RequestConveyor = RequestConveyor
        self.DialogsTransfer = DialogsTransfer
        self.updater = Thread(None, self.update, "Dialogs Update Thread")
        self.updater.daemon = True
        self.updater.start()

    def update(self):
        while True:
            y, x = self.window.getmaxyx()
            # How much dialogs should be get
            # Added 5 to allow scrolling dialogs list
            dialogsToGet = y + 10;
            request = '   var dialogs = API.messages.getDialogs({"count": ' + str(dialogsToGet) +  """});
                            return {"total": dialogs.count,
                                "total_unread": dialogs.unread_dialogs,
                                "titles": dialogs.items@.message@.title,
                                "unread": dialogs.items@.unread,
                                "user_ids": dialogs.items@.message@.user_id,
                                "name": API.users.get({"user_ids": dialogs.items@.message@.user_id})};"""
            self.RequestConveyor.add(request, DialogsToken)

            # Wait for response
            waitingForResponse = True
            while waitingForResponse:
                if not self.DialogsTransfer.empty():
                    waitingForResponse = False
                else:
                    sleep(self.RequestConveyor.interval)
            self.response = self.DialogsTransfer.get()
            self.redraw()
            sleep(self.updateInterval)

    def redraw(self):
        self.box.erase()
        y, x = self.window.getmaxyx()
        dialogs = self.response # Just to make code more readable

        # Draw header
        self.box.box()
        self.box.addstr(0, 2, "Dialogs: " + str(dialogs['total']), curses.A_BOLD)
        if dialogs['total_unread'] is not None:
            self.box.addstr(" (" + str(dialogs['total_unread']) + ")", self.boldred)

        # Draw dialogs list
        for i in range(0, y):
            # Mark unread dialogs 
            self.window.addstr(i, 1, "" if dialogs['unread'][i] is None else 
                                    "(" + str(dialogs['unread'][i]) + ") ", self.boldred)
            cy, cx = self.window.getyx()
            # Background for selected dialog
            color = curses.color_pair(2) if i == self.pos else 0
            # Users' names
            if dialogs['titles'][i] == " ... ":
                for j in range(0, len(dialogs['name']) - 1):
                    if dialogs['user_ids'][i] == dialogs['name'][j]['id']:
                        self.window.addnstr(dialogs['name'][j]['first_name'] + " " + 
                                            dialogs['name'][j]['last_name'], x - 1 - cx, color)
            # Conference titles
            else:
                self.window.addnstr(dialogs['titles'][i], x - 1 - cx, color | curses.A_BOLD)
        self.box.refresh()


class _messages:
    # Every 'updateInterval' seconds ask for update
    updateInterval = 1

    def __init__(self, stdscr, RequestConveyor, MessagesTransfer):

        # Init window
        y, x = stdscr.getmaxyx()
        self.box = stdscr.subwin(y, 3 * x // 4, 0, x // 4)
        self.window = self.box.derwin(y - 2, 3 * x // 4 - 2, 1, 1)

        # Init threads
        self.RequestConveyor = RequestConveyor
        self.MessageTransfer = MessagesTransfer
        self.updater = Thread(None, self.update, "Messages Update Thread")
        self.updater.daemon = True
        self.updater.start()

    def update(self):
        sleep(self.updateInterval)
    
    def redraw(self):
        self.box.erase()
        self.box.box()
        self.box.refresh()


class _requestConveyor:
    RequestQueue = []
    # Make requests every 'interval' seconds
    # VK API limits 3 requests per second
    interval = 0.35

    def __init__(self, api, DialogsTransfer):
        self.api = api
        self.DialogsTransfer = DialogsTransfer
        self.timer = Thread(None, self.call, "Request Conveyor Thread")
        self.timer.daemon = True
        self.timer.start()

    def add(self, request, token):
        self.RequestQueue.append({'request': request, 'token': token})
    
    def call(self):
        while True:
            if len(self.RequestQueue) > 0:
                if self.RequestQueue[0]['token'] == DialogsToken:
                   self.DialogsTransfer.put(self.api.execute(v = _API_VERSION, 
                                            code = self.RequestQueue[0]['request']))
                self.RequestQueue.pop(0)
            sleep(self.interval)


def auth(stdscr):
    vk.logger.disabled = True
    notLogged = True
    while notLogged:
        # Get login and password
        stdscr.addstr(1, 1, "vmesg " + str(_VERSION))
        stdscr.addstr(3, 1, "Login: ")
        curses.curs_set(1)
        curses.echo()
        vklogin = stdscr.getstr()
        stdscr.addstr(4, 1, "Password: ")
        curses.noecho()
        vkpass = stdscr.getstr()
        curses.curs_set(0)
        stdscr.addstr(6, 1, "Authorizing...")
        stdscr.refresh()

        # Authorization
        try:
            vksession = vk.AuthSession( app_id=_APP_ID, 
                                        user_login=vklogin, 
                                        user_password=vkpass, 
                                        scope='messages' )
        except vk.exceptions.VkAuthError:
            stdscr.addstr(7, 1, "Incorrect login or password")
        else:
            api = vk.API(vksession)
            try:
                # Just to check if API succesfully initializated
                stdscr.addstr(7, 1, "Welcome, " + api.account.getProfileInfo(v = _API_VERSION)['first_name'])
            except vk.exceptions.VkAPIError:
                stdscr.addstr(7, 1, "Cannot authorize")
            else:
                notLogged = False
        finally:
            stdscr.refresh()
            sleep(1)
            stdscr.clear()
    return api


def main(stdscr):
    # Curses setup
    curses.start_color()
    curses.use_default_colors()
    
    # Authorization
    api = auth(stdscr)

    # Data transfers between threads
    DialogsTransfer = Queue()
    MessagesTransfer = Queue()
    # Threads and classes initialization
    RequestConveyor = _requestConveyor(api, DialogsTransfer)
    Dialogs = _dialogs(stdscr, RequestConveyor, DialogsTransfer)
    Messages = _messages(stdscr, RequestConveyor, MessagesTransfer)

    while True:
        # Move through dialogs list
        if Dialogs.active:
            key = stdscr.getch()
            if key == curses.KEY_UP:
                Dialogs.pos -= 1 if Dialogs.pos > 0 else 0
                Dialogs.redraw()
            elif key == curses.KEY_DOWN:
                Dialogs.pos += 1
                Dialogs.redraw()
            elif key == 0xA: # Enter key
                Dialogs.active = False
                Messages.active = True
        elif Messages.active:
            Messages.redraw()
 

def finalizate(signum, frame):
    curses.endwin()
    exit()


if __name__ == "__main__":
    signal.signal(signal.SIGTERM, finalizate)
    signal.signal(signal.SIGINT, finalizate)
    curses.wrapper(main)
