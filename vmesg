#!/usr/bin/env python3

import curses
import vk
from queue import Queue
from threading import Thread
from time import sleep

_VERSION = 0.1
_APP_ID = 5586370
_API_VERSION = '5.57'

DialogsToken = 0
MessagesToken = 1


class _dialogs:
    # top - index of top drawed dialog, pos - current position in list
    top = 0
    pos = 0
    active = True        
    # Every 'updateInterval' seconds ask for update
    updateInterval = 1
    # Redraw every 'redrawInterval' seconds
    redrawInterval = 0.2
    # Response to request
    response = {}

    def __init__(self, stdscr, RequestConveyor, DialogsTransfer):
        # Init window
        y, x = stdscr.getmaxyx()
        self.box = stdscr.subwin(y, x // 4, 0, 0)
        self.window = self.box.derwin(y - 2, x // 4 - 2, 1, 1)

        # Init threads
        self.RequestConveyor = RequestConveyor
        self.DialogsTransfer = DialogsTransfer
        self.updater = Thread(None, self.update, "Dialogs Update Thread")
        self.updater.start()
        self.redrawer = Thread(None, self.redraw, "Dialogs Redraw Thread")
        self.redrawer.start()

    def update(self):
        while True:
            y, x = self.window.getmaxyx()
            # How much dialogs should be get
            # Added 5 to allow scrolling dialogs list
            dialogsToGet = y + 10;
            request = '   var dialogs = API.messages.getDialogs({"count": ' + str(dialogsToGet) +  """});
                            return {"total": dialogs.count,
                                "total_unread": dialogs.unread_dialogs,
                                "titles": dialogs.items@.message@.title,
                                "unread": dialogs.items@.unread,
                                "user_ids": dialogs.items@.message@.user_id,
                                "name": API.users.get({"user_ids": dialogs.items@.message@.user_id})};"""
            self.RequestConveyor.add(request, DialogsToken)

            # Wait for response
            waitingForResponse = True
            while waitingForResponse:
                if not self.DialogsTransfer.empty():
                    waitingForResponse = False
                else:
                    sleep(self.RequestConveyor.interval)
            self.response = self.DialogsTransfer.get()
            sleep(self.updateInterval)

    def redraw(self):
        while True:
            self.box.erase()
            self.window.erase()
            y, x = self.window.getmaxyx()
            _BOLDRED = curses.color_pair(1) | curses.A_BOLD
            dialogs = self.response # Just to make code more readable
            if len(dialogs) == 0:
                sleep(self.redrawInterval)
            else:

                # Draw header
                self.box.box()
                self.box.addstr(0, 2, "Dialogs: " + str(dialogs['total']), curses.A_BOLD)
                if dialogs['total_unread'] is not None:
                    self.box.addstr(" (" + str(dialogs['total_unread']) + ")", _BOLDRED)

                # Draw dialogs list
                for i in range(0, y):
                    # Mark unread dialogs 
                    self.window.addstr(i, 1, "" if dialogs['unread'][i] is None else 
                                            "(" + str(dialogs['unread'][i]) + ") ", _BOLDRED)
                    cy, cx = self.window.getyx()
                    # Users' names
                    if dialogs['titles'][i] == " ... ":
                        for j in range(0, len(dialogs['name']) - 1):
                            if dialogs['user_ids'][i] == dialogs['name'][j]['id']:
                                self.window.addnstr(dialogs['name'][j]['first_name'] + " " + 
                                                    dialogs['name'][j]['last_name'], x - 1 - cx)
                    # Conference titles
                    else:
                        self.window.addnstr(dialogs['titles'][i], x - 1 - cx, curses.A_BOLD)
                self.box.refresh()
                self.window.refresh()
                sleep(self.redrawInterval)

class _messages:
    active = False

    def __init__(self, stdscr, RequestConveyor):
        self.RequestConveyor = RequestConveyor

        # Init window
        y, x = stdscr.getmaxyx()
        self.box = stdscr.subwin(y, 3 * x // 4, 0, x // 4)
        self.box.box()
        self.window = self.box.derwin(y - 2, 3 * x // 4 - 2, 1, 1)

    def update(self):
        pass


class _requestConveyor:
    RequestQueue = []
    # Make requests every 'interval' seconds
    # VK API limits 3 requests per second
    interval = 0.35

    def add(self, request, token):
        self.RequestQueue.append({'request': request, 'token': token})
    
    def call(self):
        while True:
            if len(self.RequestQueue) > 0:
                if self.RequestQueue[0]['token'] == DialogsToken:
                   self.DialogsTransfer.put(self.api.execute(v = _API_VERSION, 
                                            code = self.RequestQueue[0]['request']))
                self.RequestQueue.pop(0)
            sleep(self.interval)

    def __init__(self, api, DialogsTransfer):
        self.api = api
        self.DialogsTransfer = DialogsTransfer
        self.timer = Thread(None, self.call, "Request Conveyor Thread")
        self.timer.start()


def auth(stdscr):
    vk.logger.disabled = True
    notLogged = True
    while notLogged:
        # Get login and password
        stdscr.addstr(1, 1, "vmesg " + str(_VERSION))
        stdscr.addstr(3, 1, "Login: ")
        curses.curs_set(1)
        curses.echo()
        vklogin = stdscr.getstr()
        stdscr.addstr(4, 1, "Password: ")
        curses.noecho()
        vkpass = stdscr.getstr()
        curses.curs_set(0)
        stdscr.addstr(6, 1, "Authorizing...")
        stdscr.refresh()

        # Authorization
        try:
            vksession = vk.AuthSession( app_id=_APP_ID, 
                                        user_login=vklogin, 
                                        user_password=vkpass, 
                                        scope='messages' )
        except vk.exceptions.VkAuthError:
            stdscr.addstr(7, 1, "Incorrect login or password")
        else:
            api = vk.API(vksession)
            try:
                # Just to check if API succesfully initializated
                stdscr.addstr(7, 1, "Welcome, " + api.account.getProfileInfo(v = _API_VERSION)['first_name'])
            except vk.exceptions.VkAPIError:
                stdscr.addstr(7, 1, "Cannot authorize")
            else:
                notLogged = False
        finally:
            stdscr.refresh()
            sleep(1)
            stdscr.clear()
    return api


def finit():
    curses.endwin()


def main(stdscr):
    # Curses setup
    curses.start_color()
    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_RED, -1)
    
    # Authorization
    api = auth(stdscr)

    # Data transfers between threads
    DialogsTransfer = Queue()
    MessagesTransfer = Queue()
    # Threads and classes initialization
    RequestConveyor = _requestConveyor(api, DialogsTransfer)
    Dialogs = _dialogs(stdscr, RequestConveyor, DialogsTransfer)
    Messages = _messages(stdscr, RequestConveyor)

    stdscr.getch()
    finit()

if __name__ == "__main__":
    curses.wrapper(main)
