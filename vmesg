#!/usr/bin/env python3

import curses
try:
    import vk
except:
    raise NameError("Unable to load VK module. Is it installed? (pip3 install vk)")
from queue import Queue
from threading import Thread
from time import sleep
from signal import signal, SIGTERM, SIGINT

VERSION = '00 Rei'
APP_ID = 5586370
API_VERSION = '5.57'

DialogsToken = 0
MessagesToken = 1


CMD_EXIT = ':q!'


class _dialogs:
    # top - index of top drawed dialog, pos - current position in list,
    # curr_id - id of currently selected user
    top = 0
    pos = 0
    curr_id = 0
    active = True
    # Every 'updateInterval' seconds ask for update
    updateInterval = 1
    # Response to request
    response = {}

    def __init__(self, stdscr, RequestConveyor, DialogsTransfer):
        # Init window
        y, x = stdscr.getmaxyx()
        self.box = stdscr.subwin(y if y < 17 else 17, x // 4, 0, 0)
        self.window = self.box.derwin(y - 2 if y < 17 else 15, x // 4 - 2, 1, 1)
        curses.init_pair(1, curses.COLOR_RED, -1)
        self.BOLD_RED = curses.color_pair(1) | curses.A_BOLD

        # Init threads
        self.RequestConveyor = RequestConveyor
        self.DialogsTransfer = DialogsTransfer
        self.response = None
        self.updater = Thread(None, self.update, "Dialogs Update Thread")
        self.updater.daemon = True
        self.updater.start()

    def update(self):
        while True:
            self.y, self.x = self.window.getmaxyx()
            # Offset for getting dialogs
            # Subtracted 10 to allow upscrolling dialogs list
            dialogsOffset = 0 if self.top < 10 else self.top - 10
            # How much dialogs should be got
            # Added 10 to allow downscrolling dialogs list
            dialogsToGet = self.y + 10
            request = """
                        var dialogs = API.messages.getDialogs({
                            "count": """ + str(dialogsToGet) + """,
                            "offset": """ + str(dialogsOffset) + """,
                            "v": """ + API_VERSION + """});
                        var titles = dialogs.items@.message@.title;
                        var user_ids = dialogs.items@.message@.user_id;
                        var names = API.users.get({
                            "user_ids": user_ids,
                            "v": """ + API_VERSION + """});
                        var isConference = [];
                        var i = """ + str(dialogsToGet) + """;
                        while (i > 0) {
                            i = i - 1;
                            var name;
                            var j = 0;
                            if (titles[i] == " ... ") {
                                isConference.unshift(false);
                                var breakFlag = false;
                                while (j < names.length && !breakFlag) {
                                    if (user_ids[i] == names[j].id) {
                                        name = names[j].first_name + " " + names[j].last_name;
                                        breakFlag = true;
                                    }
                                    j = j + 1;
                                }
                                titles.splice(i, 1, name);
                            }
                            else {
                                isConference.unshift(true);
                            }
                        }
                        return {
                            "total": dialogs.count,
                            "total_unread": dialogs.unread_dialogs,
                            "unread": dialogs.items@.unread,
                            "isConference": isConference,
                            "titles": titles,
                            "uids": user_ids
                        };"""
            self.RequestConveyor.add(request, DialogsToken)

            # Wait for response
            waitingForResponse = True
            while waitingForResponse:
                if not self.DialogsTransfer.empty():
                    waitingForResponse = False
                else:
                    sleep(self.RequestConveyor.interval)
            self.response = self.DialogsTransfer.get()
            self.redraw()
            sleep(self.updateInterval)

    def redraw(self):
        dialogs = self.response # Just to make code more readable
        self.box.erase()

        # Draw header
        self.box.box()
        self.box.addstr(0, 2, "Dialogs: " + str(dialogs['total']), curses.A_BOLD)
        if dialogs['total_unread'] is not None:
            self.box.addstr(" (" + str(dialogs['total_unread']) + ")", self.BOLD_RED)

        # Draw dialogs list
        for i in range(0, self.y):
            # Mark unread dialogs
            dialogNum = i + (self.top if self.top < 10 else 10) # Just to make code more readable
            self.window.addstr(i, 1, "" if dialogs['unread'][dialogNum] is None else
                            "(" + str(dialogs['unread'][dialogNum]) + ") ", self.BOLD_RED)
            cy, cx = self.window.getyx()
            # Background for selected dialog
            highlight = curses.A_REVERSE if dialogNum == self.pos else 0
            # Bold for conferences
            highlight |= curses.A_BOLD if dialogs['isConference'][dialogNum] else 0
            self.window.addnstr(dialogs['titles'][dialogNum], self.x - 1 - cx, highlight)
        self.box.refresh()


class _messages:
    active = False
    # Every 'updateInterval' seconds ask for update
    updateInterval = 1

    def __init__(self, stdscr, Dialogs, RequestConveyor, MessagesTransfer):
        # Init window
        y, x = stdscr.getmaxyx()
        self.box = stdscr.subwin(y, 3 * x // 4, 0, x // 4)
        self.window = self.box.derwin(y - 2, 3 * x // 4 - 4, 1, 2)
        self.window.scrollok(True)
        self.BOLD_RED = curses.color_pair(1) | curses.A_BOLD
        # Init message send window
        self.msgBox = stdscr.subwin(3, 3 * x // 4, 0, x // 4)
        self.msgWindow = self.msgBox.derwin(1, 3 * x // 4 - 2, 1, 1)

        # Init threads
        self.Dialogs = Dialogs
        self.RequestConveyor = RequestConveyor
        self.MessagesTransfer = MessagesTransfer
        self.updater = Thread(None, self.update, "Messages Update Thread")
        self.updater.daemon = True
        self.updater.start()

    def update(self):
        while True:
            if self.Dialogs.response:
                # Selected dialog's id
                self.active_id = self.Dialogs.response['uids'][self.Dialogs.pos]
                # How much messages should be got
                messagesToGet = 50
                request = """   var to_id = """ + str(self.active_id) + """;
                                var  messages = API.messages.getHistory({
                                    "count": """ + str(messagesToGet) + """,
                                    "user_id": to_id,
                                    "v": """ + API_VERSION + """});
                                var names = API.users.get({
                                    "user_ids": messages.items@.from_id,
                                    "v": """ + API_VERSION + """});
                                return {
                                    "text": messages.items@.body,
                                    "ids": messages.items@.from_id,
                                    "names": names
                                }; """
                self.RequestConveyor.add(request, MessagesToken)

                # Wait for response
                waitingForResponse = True
                while waitingForResponse:
                    if not self.MessagesTransfer.empty():
                        waitingForResponse = False
                    else:
                        sleep(self.RequestConveyor.interval)
                self.response = self.MessagesTransfer.get()
                self.redraw()
            sleep(self.updateInterval)

    def send(self):
        curses.echo()
        message = self.msgWindow.getstr(1, 1)
        curses.noecho()
        if message == CMD_EXIT:
            self.active = False
            self.Dialogs.active = True
            return
        request = """   var to_id = """ + str(self.active_id) + """;
                        API.messages.send({
                            "user_id": to_id,
                            "message": " """ + str(message) + """ ",
                            "v": """ + API_VERSION + """});
                        return 1;"""
        self.RequestConveyor.add(request, -1)

    def redraw(self):
        messages = self.response # Just to make code more readable
        self.box.erase()
        self.box.box()
        y, x = self.window.getmaxyx()
        cy = y # Row where message would be printed
        for i in range(0, len(messages["text"])):
            try:
                name = messages["names"][messages["names"][0]["id"] != messages["ids"][i]]["first_name"]
                msg = str(messages["text"][i])
                cy -= (len(name) + len(msg)) // (x - 2) + 1
                self.window.addstr(cy, 0, name + ": ", self.BOLD_RED)
                self.window.addstr(msg)
            except:
                break
        self.box.refresh()


class _requestConveyor:
    RequestQueue = []
    # Make requests every 'interval' seconds
    # VK API limits 3 requests per second
    interval = 0.35

    def __init__(self, api, DialogsTransfer, MessagesTransfer):
        self.api = api
        self.DialogsTransfer = DialogsTransfer
        self.MessagesTransfer = MessagesTransfer
        self.timer = Thread(None, self.call, "Request Conveyor Thread")
        self.timer.daemon = True
        self.timer.start()

    def add(self, request, token):
        self.RequestQueue.append({'request': request, 'token': token})

    def call(self):
        while True:
            if len(self.RequestQueue) > 0:
                response = self.api.execute(v = API_VERSION,
                                            code = self.RequestQueue[0]['request'])
                if self.RequestQueue[0]['token'] == DialogsToken:
                    self.DialogsTransfer.put(response)
                elif self.RequestQueue[0]['token'] == MessagesToken:
                    self.MessagesTransfer.put(response)
                self.RequestQueue.pop(0)
            sleep(self.interval)


def auth(stdscr):
    vk.logger.disabled = True
    notLogged = True
    while notLogged:
        # Get login and password
        stdscr.addstr(1, 1, "vmesg " + VERSION)
        stdscr.addstr(3, 1, "Login: ")
        curses.curs_set(1)
        curses.echo()
        vklogin = stdscr.getstr()
        stdscr.addstr(4, 1, "Password: ")
        curses.noecho()
        vkpass = stdscr.getstr()
        curses.curs_set(0)
        stdscr.addstr(6, 1, "Authorizing...")
        stdscr.refresh()

        # Authorization
        try:
            vksession = vk.AuthSession( app_id = APP_ID,
                                        user_login = vklogin,
                                        user_password = vkpass,
                                        scope = 'messages' )
        except vk.exceptions.VkAuthError:
            stdscr.addstr(7, 1, "Incorrect login or password")
        else:
            api = vk.API(vksession)
            try:
                # Just to check if API was initializated succesfully
                stdscr.addstr(7, 1, "Welcome, " + api.account.getProfileInfo(v = API_VERSION)['first_name'])
            except vk.exceptions.VkAPIError:
                stdscr.addstr(7, 1, "Cannot authorize")
            else:
                notLogged = False
        finally:
            stdscr.refresh()
            sleep(1)
            stdscr.clear()
    return api


def main(stdscr):
    # Curses setup
    curses.start_color()
    curses.use_default_colors()

    # Authorization
    api = auth(stdscr)

    # Data transfers between threads
    DialogsTransfer = Queue()
    MessagesTransfer = Queue()
    # Threads and classes initialization
    RequestConveyor = _requestConveyor(api, DialogsTransfer, MessagesTransfer)
    Dialogs = _dialogs(stdscr, RequestConveyor, DialogsTransfer)
    Messages = _messages(stdscr, Dialogs, RequestConveyor, MessagesTransfer)

    while True:
        # Move through dialogs list
        if Dialogs.active:
            key = stdscr.getch()
            if key == curses.KEY_UP:
                Dialogs.pos -= 1 if Dialogs.pos > 0 else 0
                if Dialogs.pos < Dialogs.top:
                    Dialogs.top -= 1
                Dialogs.redraw()
            elif key == curses.KEY_DOWN:
                Dialogs.pos += 1 if Dialogs.pos < Dialogs.response['total'] else 0
                if Dialogs.pos - Dialogs.top == Dialogs.y:
                    Dialogs.top += 1
                Dialogs.redraw()
            elif key == 0x0A: # Enter key
                Dialogs.active = False
                Messages.active = True
        else:
            pass
            # Messages.send()


def finalizate(signum, frame):
    curses.endwin()
    exit()


if __name__ == "__main__":
    signal(SIGTERM, finalizate)
    signal(SIGINT, finalizate)
    curses.wrapper(main)
